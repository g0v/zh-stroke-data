// Generated by LiveScript 1.2.0
(function(){
  var slice$ = [].slice;
  $(function(){
    return $.get('../../orig-chars.json', function(OrigChars){
      var shiftFloat, shapeFromOutline, scale, dim, cols, start, count, scene, camera, light, renderer, render, failed, i$, results$ = [];
      shiftFloat = function(){
        return parseFloat(this.shift());
      };
      shapeFromOutline = function(it){
        var shape, path, current, tokens;
        shape = new THREE.Shape;
        path = new THREE.Path;
        current = shape;
        tokens = it.split(' ');
        tokens.shiftFloat = shiftFloat;
        while (tokens.length) {
          switch (tokens.shift()) {
          case 'M':
            current.moveTo(tokens.shiftFloat(), tokens.shiftFloat());
            break;
          case 'L':
            while (tokens.length > 1) {
              current.lineTo(tokens.shiftFloat(), tokens.shiftFloat());
              if (tokens[0] === 'Z') {
                if (current !== shape) {
                  shape.holes.push(path);
                  path = new THREE.Path;
                }
                current = path;
                break;
              }
            }
          }
        }
        return shape;
      };
      scale = 0.025;
      dim = 2150;
      cols = 20;
      start = 0;
      count = 240;
      scene = new THREE.Scene;
      camera = new THREE.OrthographicCamera(0, window.innerWidth / scale, 0, -window.innerHeight / scale, 1, 1000);
      camera.position.set(0, 0, 500);
      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(0, 0, 1);
      scene.add(light);
      renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      $('#container').append(renderer.domElement);
      render = function(){
        requestAnimationFrame(render);
        return renderer.render(scene, camera);
      };
      requestAnimationFrame(render);
      failed = [];
      for (i$ = start; i$ < count; ++i$) {
        results$.push((fn$.call(this, i$)));
      }
      return results$;
      function fn$(i){
        var c;
        c = OrigChars[i];
        return $.get("./a/" + c + ".json", function(data){
          var j, ref$, outline, x, y, color, lineColor, log, geometry, offset, m, mesh;
          for (j in ref$ = data != null ? data.outlines : void 8) {
            outline = ref$[j];
            x = ~~(i % cols);
            y = ~~(i / cols);
            color = 0xffcc00;
            lineColor = 0xee6600;
            log = console.log;
            console.log = fn$;
            geometry = new THREE.ShapeGeometry(shapeFromOutline(outline));
            console.log = log;
            offset = new THREE.Vector2(+data.centroids[j][0], -data.centroids[j][1]);
            m = new THREE.Matrix4;
            m.makeTranslation(-offset.x, -offset.y, 0);
            geometry.applyMatrix(m);
            mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [
              new THREE.MeshLambertMaterial({
                color: color
              }), new THREE.MeshBasicMaterial({
                color: lineColor,
                wireframe: true,
                transparent: true
              })
            ]);
            mesh.position.set(x * dim + offset.x, -y * dim + offset.y, 0);
            scene.add(mesh);
          }
          if (i === count - 1) {
            return console.log(failed);
          }
          function fn$(){
            var args, i$, len$, str;
            args = slice$.call(arguments);
            for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
              str = args[i$];
              if (str.match(/triangulate/)) {
                color = 0x330000;
                lineColor = 0xff0000;
                failed.push({
                  ch: data.ch,
                  outline: j
                });
                break;
              }
            }
            return log.apply(console, args);
          }
        });
      }
    });
  });
}).call(this);
