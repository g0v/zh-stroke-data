// Generated by LiveScript 1.3.1
(function(){
  var React, ref$, svg, g, path, defs, clipPath, packageName, Track, compTrack, Stroke, compStroke, Word;
  React = require('react');
  ref$ = React.DOM, svg = ref$.svg, g = ref$.g, path = ref$.path, defs = ref$.defs, clipPath = ref$.clipPath;
  packageName = 'zhStroker';
  Track = React.createClass({
    displayName: packageName + ".Track",
    getDefaultProps: function(){
      return {
        data: {
          bgn: {
            x: 0,
            y: 0,
            length: 0
          },
          end: {
            x: 0,
            y: 0
          }
        },
        x: 0,
        y: 0,
        progress: Infinity
      };
    },
    render: function(){
      var ref$, bgn, end, progress, ratio, dx, dy, track, valid;
      ref$ = this.props.data, bgn = ref$.bgn, end = ref$.end;
      progress = this.props.progress;
      if (progress < 0) {
        progress = 0;
      }
      if (progress > bgn.length) {
        progress = bgn.length;
      }
      ratio = progress / bgn.length;
      dx = (end.x - bgn.x) * ratio;
      dy = (end.y - bgn.y) * ratio;
      track = "M" + bgn.x + " " + bgn.y + " L" + (bgn.x + dx) + " " + (bgn.y + dy);
      valid = !isNaN(ratio) && ratio !== Infinity && ratio !== 0;
      return g({
        x: this.props.x,
        y: this.props.y
      }, path({
        d: valid ? track : 'M0 0 L0 0',
        fill: 'transparent',
        stroke: '#000',
        strokeWidth: valid ? 4 * bgn.size || 250 : 0,
        strokeLinecap: 'round'
      }));
    }
  });
  compTrack = React.createFactory(Track);
  Stroke = React.createClass({
    displayName: packageName + ".Stroke",
    getDefaultProps: function(){
      return {
        data: {
          outline: [],
          track: [],
          length: 0
        },
        x: 0,
        y: 0,
        progress: Infinity,
        onEnterStroke: function(){},
        onLeaveStroke: function(){}
      };
    },
    injectClipPath: function(){
      return this.refs.stroke.getDOMNode().setAttribute('clip-path', "url(#" + this.id + ")");
    },
    componentWillReceiveProps: function(next){
      var length;
      length = this.props.data.length;
      if (this.props.progress <= 0 && next.progress > 0) {
        this.props.onEnterStroke();
      }
      if (this.props.progress <= length && next.progress > length) {
        return this.props.onLeaveStroke();
      }
    },
    componentDidMount: function(){
      return this.injectClipPath.apply(this, arguments);
    },
    componentDidUpdate: function(){
      return this.injectClipPath.apply(this, arguments);
    },
    render: function(){
      var length, progress, outline, res$, i$, ref$, len$, cmd, track, i, bgn, end, comp;
      length = this.props.data.length;
      progress = this.props.progress;
      if (progress < 0) {
        progress = 0;
      }
      if (progress > length) {
        progress = length;
      }
      res$ = [];
      for (i$ = 0, len$ = (ref$ = this.props.data.outline).length; i$ < len$; ++i$) {
        cmd = ref$[i$];
        switch (cmd.type) {
        case 'M':
          res$.push("M " + cmd.x + " " + cmd.y);
          break;
        case 'L':
          res$.push("L " + cmd.x + " " + cmd.y);
          break;
        case 'Q':
          res$.push("Q " + cmd.begin.x + " " + cmd.begin.y + ", " + cmd.end.x + " " + cmd.end.y);
          break;
        case 'C':
          res$.push("C " + cmd.begin.x + " " + cmd.begin.y + ", " + cmd.mid.x + " " + cmd.mid.y + ", " + cmd.end.x + " " + cmd.end.y);
        }
      }
      outline = res$;
      outline = outline.join(' ') + " Z";
      this.id = outline.replace(new RegExp(' ', 'g'), '%20');
      track = this.props.data.track;
      return g({
        ref: 'stroke',
        x: this.props.x,
        y: this.props.y
      }, defs({}, React.createElement('clipPath', {
        id: this.id
      }, path({
        d: outline,
        fill: '#F00'
      }))), (function(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = track.length - 1; i$ < to$; ++i$) {
          i = i$;
          bgn = track[i];
          end = track[i + 1];
          comp = compTrack({
            key: i,
            data: {
              bgn: bgn,
              end: end
            },
            progress: progress
          });
          progress -= bgn.length;
          results$.push(comp);
        }
        return results$;
      }()));
    }
  });
  compStroke = React.createFactory(Stroke);
  Word = React.createClass({
    displayName: packageName + ".Word",
    getDefaultProps: function(){
      return {
        data: {
          word: [],
          length: 0
        },
        x: 0,
        y: 0,
        width: 410,
        height: 410,
        progress: Infinity,
        onEnter: function(){},
        onLeave: function(){},
        onEnterStroke: function(){},
        onLeaveStroke: function(){}
      };
    },
    componentWillReceiveProps: function(next){
      var length;
      length = this.props.data.length;
      if (this.props.progress <= 0 && next.progress > 0) {
        this.props.onEnter();
      }
      if (this.props.progress <= length && next.progress > length) {
        return this.props.onLeave();
      }
    },
    render: function(){
      var ref$, length, word, progress, i, stroke, comp;
      ref$ = this.props.data, length = ref$.length, word = ref$.word;
      progress = this.props.progress;
      if (progress < 0) {
        progress = 0;
      }
      if (progress > length) {
        progress = length;
      }
      return svg({
        width: this.props.width,
        height: this.props.height,
        viewBox: "0 0 2050 2050",
        version: 1.1,
        xmlns: '"http://www.w3.org/2000/svg'
      }, g({
        x: this.props.x,
        y: this.props.y
      }, (function(){
        var ref$, results$ = [];
        for (i in ref$ = word) {
          stroke = ref$[i];
          comp = compStroke({
            key: i,
            data: stroke,
            progress: progress,
            onEnterStroke: this.props.onEnterStroke,
            onLeaveStroke: this.props.onLeaveStroke
          });
          progress -= stroke.length;
          results$.push(comp);
        }
        return results$;
      }.call(this))));
    }
  });
  /**
  class ScanlineTrack extends Comp
    (@data) ->
      super!
      @scale-x = @scale-y = 2
      # FIXME: rethink the workflow in super
      @computeAABB!
      @length *= 2
    computeLength: ->
      @length = @data.lines.length
    computeAABB: ->
      direction = @data.direction
      @aabb = new AABB
      for { idx, start, end } in @data.lines
        if direction is 0 # vertical
          @aabb.addBox new AABB {
            x: start * @scale-x + @x
            y: idx   * @scale-y + @y
          }, {
            x: end       * @scale-x + @x
            y: (idx + 1) * @scale-y + @y
          }
        else if direction is 1 # horizontal
          @aabb.addBox new AABB {
            x: idx   * @scale-x + @x
            y: start * @scale-y + @y
          }, {
            x: (idx + 1) * @scale-x + @x
            y: end       * @scale-y + @y
          }
      @aabb
    doRender: (ctx) !->
      direction = @data.direction
      ctx
        ..beginPath!
        ..fillStyle = \#000
      for i from 0 til ~~(@data.lines.length * @time)
        { idx, start, end } = @data.lines[i]
        if direction is 0
          ctx.fillRect do
            start     * @scale-x + @x
            (idx - 1) * @scale-y + @y
            (end - start) * @scale-x
            @scale-y * 2
        else if direction is 1
          ctx.fillRect do
            (idx - 1) * @scale-x + @x
            start     * @scale-y + @y
            @scale-x * 2
            (end - start) * @scale-y
  
  class ScanlineStroke extends Comp
    (data) ->
      children = for track in data
        new ScanlineTrack track
      super children
  /**/
  module.exports = {
    Word: Word,
    Stroke: Stroke,
    Track: Track
  };
}).call(this);
