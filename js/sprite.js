// Generated by LiveScript 1.2.0
(function(){
  var AABB, Comp, Empty, Track, Stroke, Arrow, x$, ref$;
  AABB = (function(){
    AABB.displayName = 'AABB';
    var axises, scan, prototype = AABB.prototype, constructor = AABB;
    axises = ['x', 'y'];
    scan = function(group, axis){
      var points, i$, len$, box, groups, g, d, p;
      switch (false) {
      case !!Array.isArray(group):
        throw new Error('first argument should be an array');
      case group[0].min[axis] !== undefined:
        throw new Error('axis not found');
      default:
        points = [];
        for (i$ = 0, len$ = group.length; i$ < len$; ++i$) {
          box = group[i$];
          if (!box.isEmpty()) {
            points.push({
              box: box,
              value: box.min[axis],
              depth: 1
            });
            points.push({
              value: box.max[axis],
              depth: -1
            });
          }
        }
        points.sort(function(a, b){
          switch (false) {
          case !(a.value < b.value):
            return -1;
          case a.value !== b.value:
            return 0;
          case !(a.value > b.value):
            return 1;
          }
        });
        groups = [];
        g = [];
        d = 0;
        for (i$ = 0, len$ = points.length; i$ < len$; ++i$) {
          p = points[i$];
          d += p.depth;
          if (d !== 0) {
            if (p.box) {
              g.push(p.box);
            }
          } else {
            groups.push(g);
            g = [];
          }
        }
        return groups;
      }
    };
    AABB.rdc = function(g, todo){
      var results, res$, i$, len$, axis, gs, next;
      todo == null && (todo = axises.slice());
      switch (false) {
      case !!Array.isArray(g):
        throw new Error('first argument should be an array');
      default:
        res$ = [];
        for (i$ = 0, len$ = todo.length; i$ < len$; ++i$) {
          axis = todo[i$];
          gs = scan(g, axis);
          if (gs.length > 1) {
            next = axises.slice();
            next.splice(next.indexOf(axis), 1);
            res$.push(Array.prototype.concat.apply([], (fn$.call(this))));
          } else {
            res$.push(gs);
          }
        }
        results = res$;
        return results.reduce(function(c, n){
          if (c.length > n.length) {
            return c;
          } else {
            return n;
          }
        });
      }
      function fn$(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = gs).length; i$ < len$; ++i$) {
          g = ref$[i$];
          results$.push(this.rdc(g, next));
        }
        return results$;
      }
    };
    AABB.collide = function(it){
      var result, i$, to$, i, j$, to1$, j;
      switch (false) {
      case !!Array.isArray(it):
        throw new Error('first argument should be an array');
      default:
        result = [];
        for (i$ = 0, to$ = it.length; i$ < to$; ++i$) {
          i = i$;
          for (j$ = i + 1, to1$ = it.length; j$ < to1$; ++j$) {
            j = j$;
            if (it[i].intersect(it[j])) {
              result.push([it[i], it[j]]);
            }
          }
        }
        return result;
      }
    };
    AABB.hit = function(it){
      var g;
      switch (false) {
      case !!Array.isArray(it):
        throw new Error('first argument should be an array');
      default:
        return Array.prototype.concat.apply([], (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = this.rdc(it)).length; i$ < len$; ++i$) {
            g = ref$[i$];
            results$.push(this.collide(g));
          }
          return results$;
        }.call(this)));
      }
    };
    function AABB(min, max){
      this.min = min != null
        ? min
        : {
          x: Infinity,
          y: Infinity
        };
      this.max = max != null
        ? max
        : {
          x: -Infinity,
          y: -Infinity
        };
      if (isNaN(this.min.x)) {
        this.min.x = Infinity;
      }
      if (isNaN(this.min.y)) {
        this.min.y = Infinity;
      }
      if (isNaN(this.max.x)) {
        this.max.x = -Infinity;
      }
      if (isNaN(this.max.y)) {
        this.max.y = -Infinity;
      }
    }
    Object.defineProperty(prototype, 'width', {
      get: function(){
        return this.max.x - this.min.x;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'height', {
      get: function(){
        return this.max.y - this.min.y;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'size', {
      get: function(){
        return this.width * this.height;
      },
      configurable: true,
      enumerable: true
    });
    prototype.isEmpty = function(){
      return this.min.x >= this.max.x || this.min.y >= this.max.y;
    };
    prototype.clone = function(){
      return new AABB(this.min, this.max);
    };
    prototype.transform = function(m00, m01, m10, m11, m20, m21){
      var aabb;
      aabb = new AABB({
        x: m00 * this.min.x + m10 * this.min.y + m20,
        y: m01 * this.min.x + m11 * this.min.y + m21
      }, {
        x: m00 * this.max.x + m10 * this.max.y + m20,
        y: m01 * this.max.x + m11 * this.max.y + m21
      });
      return aabb;
    };
    prototype.addPoint = function(pt){
      if (pt.x < this.min.x) {
        this.min.x = pt.x;
      }
      if (pt.y < this.min.y) {
        this.min.y = pt.y;
      }
      if (pt.x > this.max.x) {
        this.max.x = pt.x;
      }
      if (pt.y > this.max.y) {
        this.max.y = pt.y;
      }
    };
    prototype.addBox = function(aabb){
      if (aabb.min.x < this.min.x) {
        this.min.x = aabb.min.x;
      }
      if (aabb.min.y < this.min.y) {
        this.min.y = aabb.min.y;
      }
      if (aabb.max.x > this.max.x) {
        this.max.x = aabb.max.x;
      }
      if (aabb.max.y > this.max.y) {
        this.max.y = aabb.max.y;
      }
    };
    prototype.containPoint = function(pt){
      var ref$;
      return (this.min.x < (ref$ = pt.x) && ref$ < this.max.x) && (this.min.y < (ref$ = pt.y) && ref$ < this.max.y);
    };
    prototype.intersect = function(it){
      return this.min.x <= it.max.x && this.max.x >= it.min.x && this.min.y <= it.max.y && this.max.y >= it.min.y;
    };
    prototype.render = function(ctx, color, width){
      var x$;
      color == null && (color = '#f90');
      width == null && (width = 10);
      if (this.isEmpty()) {
        return;
      }
      x$ = ctx;
      x$.strokeStyle = color;
      x$.lineWidth = width;
      x$.beginPath();
      x$.rect(this.min.x, this.min.y, this.width, this.height);
      x$.stroke();
    };
    return AABB;
  }());
  Comp = (function(){
    Comp.displayName = 'Comp';
    var prototype = Comp.prototype, constructor = Comp;
    function Comp(children){
      var i$, ref$, len$, child;
      this.children = children != null
        ? children
        : [];
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        child.parent = this;
      }
      this.computeAABB();
      this.computeLength();
      this.time = 0.0;
      this.x = this.y = 0;
      this.scaleX = this.scaleY = 1.0;
      this.parent = null;
    }
    prototype.computeLength = function(){
      return this.length = this.children.reduce(function(prev, current){
        return prev + current.length;
      }, 0);
    };
    prototype.computeAABB = function(){
      var i$, ref$, len$, c;
      this.aabb = new AABB;
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
        c = ref$[i$];
        this.aabb.addBox(c.aabb.transform(c.scaleX, 0, 0, c.scaleY, c.x, c.y));
      }
      return this.aabb;
    };
    prototype.globalAABB = function(){
      var aabb, p;
      aabb = this.aabb;
      p = this;
      while (p) {
        aabb = aabb.transform(p.scaleX, 0, 0, p.scaleY, p.x, p.y);
        p = p.parent;
      }
      return aabb;
    };
    prototype.childrenChanged = function(){
      var len, i$, ref$, len$, child;
      this.computeLength();
      len = 0;
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        len += child.time * child.length;
      }
      this.time = len / this.length;
      if ((ref$ = this.parent) != null) {
        ref$.childrenChanged();
      }
    };
    prototype.breakUp = function(strokeNums){
      var comps, this$ = this;
      strokeNums == null && (strokeNums = []);
      comps = [];
      strokeNums.reduce(function(start, len){
        var end;
        end = start + len;
        comps.push(new Comp(this$.children.slice(start, end)));
        return end;
      }, 0);
      return new Comp(comps);
    };
    prototype.hitTest = function(pt){
      var results;
      results = [];
      if (this.aabb.containPoint(pt)) {
        results.push(this);
      }
      return this.children.reduce(function(prev, child){
        return prev.concat(child.hitTest(pt));
      }, results);
    };
    prototype.beforeRender = function(ctx){
      var x$;
      x$ = ctx;
      x$.save();
      x$.transform(this.scaleX, 0, 0, this.scaleY, this.x, this.y);
    };
    prototype.doRender = function(ctx){};
    prototype.afterRender = function(ctx){
      ctx.restore();
    };
    prototype.render = function(ctx, aabb){
      var len, i$, ref$, len$, child;
      aabb == null && (aabb = false);
      this.beforeRender(ctx);
      if (aabb) {
        this.aabb.render(ctx);
      }
      len = this.length * this.time;
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        if (len > 0) {
          if (child.length === 0) {
            continue;
          }
          child.time = Math.min(child.length, len) / child.length;
          child.render(ctx, aabb);
          len -= child.length;
        }
      }
      this.doRender(ctx);
      this.afterRender(ctx);
    };
    return Comp;
  }());
  Empty = (function(superclass){
    var prototype = extend$((import$(Empty, superclass).displayName = 'Empty', Empty), superclass).prototype, constructor = Empty;
    function Empty(data){
      this.data = data;
      this.render = bind$(this, 'render', prototype);
      Empty.superclass.call(this);
    }
    prototype.computeLength = function(){
      return this.length = this.data.speed * this.data.delay;
    };
    prototype.computeAABB = function(){
      return this.aabb = new AABB;
    };
    prototype.render = function(){};
    return Empty;
  }(Comp));
  Track = (function(superclass){
    var prototype = extend$((import$(Track, superclass).displayName = 'Track', Track), superclass).prototype, constructor = Track;
    function Track(data, options){
      var ref$;
      this.data = data;
      this.options = options != null
        ? options
        : {};
      (ref$ = this.options).trackWidth || (ref$.trackWidth = 150);
      (ref$ = this.data).size || (ref$.size = this.options.trackWidth);
      Track.superclass.call(this);
    }
    prototype.computeLength = function(){
      return this.length = Math.sqrt(this.data.vector.x * this.data.vector.x + this.data.vector.y * this.data.vector.y);
    };
    prototype.computeAABB = function(){
      return this.aabb = new AABB({
        x: this.data.x,
        y: this.data.y
      }, {
        x: this.data.x + this.data.vector.x,
        y: this.data.y + this.data.vector.y
      });
    };
    prototype.doRender = function(ctx){
      var x$;
      x$ = ctx;
      x$.beginPath();
      x$.strokeStyle = '#000';
      x$.fillStyle = '#000';
      x$.lineWidth = 4 * this.data.size;
      x$.lineCap = 'round';
      x$.moveTo(this.data.x, this.data.y);
      x$.lineTo(this.data.x + this.data.vector.x * this.time, this.data.y + this.data.vector.y * this.time);
      x$.stroke();
    };
    return Track;
  }(Comp));
  Stroke = (function(superclass){
    var prototype = extend$((import$(Stroke, superclass).displayName = 'Stroke', Stroke), superclass).prototype, constructor = Stroke;
    function Stroke(data){
      var children, i$, to$, i, prev, current;
      children = [];
      for (i$ = 1, to$ = data.track.length; i$ < to$; ++i$) {
        i = i$;
        prev = data.track[i - 1];
        current = data.track[i];
        children.push(new Track({
          x: prev.x,
          y: prev.y,
          vector: {
            x: current.x - prev.x,
            y: current.y - prev.y
          },
          size: prev.size
        }));
      }
      this.outline = data.outline;
      Stroke.superclass.call(this, children);
    }
    prototype.computeAABB = function(){
      var i$, ref$, len$, path;
      this.aabb = new AABB;
      for (i$ = 0, len$ = (ref$ = this.outline).length; i$ < len$; ++i$) {
        path = ref$[i$];
        if (path.x !== undefined) {
          this.aabb.addPoint(path);
        }
        if (path.end !== undefined) {
          this.aabb.addPoint(path.begin);
          this.aabb.addPoint(path.end);
        }
        if (path.mid !== undefined) {
          this.aabb.addPoint(path.mid);
        }
      }
      return this.aabb;
    };
    prototype.pathOutline = function(ctx){
      var i$, ref$, len$, path;
      for (i$ = 0, len$ = (ref$ = this.outline).length; i$ < len$; ++i$) {
        path = ref$[i$];
        switch (path.type) {
        case 'M':
          ctx.moveTo(path.x, path.y);
          break;
        case 'L':
          ctx.lineTo(path.x, path.y);
          break;
        case 'C':
          ctx.bezierCurveTo(path.begin.x, path.begin.y, path.mid.x, path.mid.y, path.end.x, path.end.y);
          break;
        case 'Q':
          ctx.quadraticCurveTo(path.begin.x, path.begin.y, path.end.x, path.end.y);
        }
      }
    };
    prototype.beforeRender = function(ctx){
      var x$;
      superclass.prototype.beforeRender.call(this, ctx);
      x$ = ctx;
      x$.save();
      x$.beginPath();
      this.pathOutline(ctx);
      ctx.clip();
    };
    prototype.afterRender = function(ctx){
      ctx.restore();
      superclass.prototype.afterRender.call(this, ctx);
    };
    return Stroke;
  }(Comp));
  Arrow = (function(superclass){
    var prototype = extend$((import$(Arrow, superclass).displayName = 'Arrow', Arrow), superclass).prototype, constructor = Arrow;
    function Arrow(stroke, index){
      var max, track0, track, i$, ref$, len$, t, data, angle, x, y;
      this.stroke = stroke;
      this.index = index;
      max = stroke.children.reduce(function(c, n){
        if (c.length > n.length) {
          return c;
        } else {
          return n;
        }
      });
      track0 = stroke.children[0];
      for (i$ = 0, len$ = (ref$ = stroke.children).length; i$ < len$; ++i$) {
        t = ref$[i$];
        if (t.length > max.length / 2.5) {
          track = t;
          break;
        }
      }
      data = track.data;
      this.vector = {
        x: data.vector.x / track.length,
        y: data.vector.y / track.length
      };
      angle = Math.atan2(this.vector.y, this.vector.x);
      angle = Math.PI / 2 > angle && angle >= -Math.PI / 2
        ? angle - Math.PI / 2
        : angle + Math.PI / 2;
      this.up = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
      x = data.size / 2 * this.vector.x;
      y = data.size / 2 * this.vector.y;
      x += data.size / 2 * this.up.x;
      y += data.size / 2 * this.up.y;
      this.textSize = 48;
      this.arrow = {
        rear: {
          x: x - this.textSize * this.vector.x,
          y: y - this.textSize * this.vector.y
        },
        tip: {
          x: x + 2 * this.textSize * this.vector.x,
          y: y + 2 * this.textSize * this.vector.y
        },
        text: {
          x: x + this.textSize * this.up.x,
          y: y + this.textSize * this.up.y
        },
        textMin: {
          x: x + this.textSize * this.up.x - this.textSize,
          y: y + this.textSize * this.up.y - this.textSize
        },
        textMax: {
          x: x + this.textSize * this.up.x + this.textSize,
          y: y + this.textSize * this.up.y + this.textSize
        },
        head: {
          x: x + this.textSize * this.vector.x,
          y: y + this.textSize * this.vector.y
        },
        edge: {
          x: x + this.textSize * this.vector.x + this.textSize * this.up.x,
          y: y + this.textSize * this.vector.y + this.textSize * this.up.y
        }
      };
      Arrow.superclass.call(this);
      this.x = stroke.x + track0.data.x;
      this.y = stroke.y + track0.data.y;
    }
    prototype.computeLength = function(){
      return this.length = this.stroke.length;
    };
    prototype.computeAABB = function(){
      var key;
      this.aabb = new AABB;
      for (key in this.arrow) {
        this.aabb.addPoint(this.arrow[key]);
      }
      return this.aabb;
    };
    prototype.doRender = function(ctx){
      var x$;
      x$ = ctx;
      x$.strokeStyle = '#c00';
      x$.lineWidth = 12;
      x$.beginPath();
      x$.moveTo(this.arrow.rear.x, this.arrow.rear.y);
      x$.lineTo(this.arrow.tip.x, this.arrow.tip.y);
      x$.stroke();
      x$.fillStyle = '#c00';
      x$.beginPath();
      x$.moveTo(this.arrow.head.x, this.arrow.head.y);
      x$.lineTo(this.arrow.tip.x, this.arrow.tip.y);
      x$.lineTo(this.arrow.edge.x, this.arrow.edge.y);
      x$.fill();
      x$.font = 2 * this.textSize + "px sans-serif";
      x$.textAlign = 'center';
      x$.textBaseline = 'middle';
      x$.fillText(this.index, this.arrow.text.x, this.arrow.text.y);
    };
    return Arrow;
  }(Comp));
  x$ = (ref$ = window.zhStrokeData) != null
    ? ref$
    : window.zhStrokeData = {};
  x$.AABB = AABB;
  x$.Comp = Comp;
  x$.Empty = Empty;
  x$.Track = Track;
  x$.Stroke = Stroke;
  x$.Arrow = Arrow;
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
